<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Fireworks Canvas</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: transparent;
  }
  canvas {
    position: fixed;
    inset: 0;
    display: block;
    width: 100vw;
    height: 100vh;
    background: transparent;
    pointer-events: none;
  }
  #fw-canvas { z-index: 1; }
  #stars-canvas { z-index: 2; }
  .hearts {
    position: fixed;
    inset: 0;
    z-index: 3;
    pointer-events: none;
    overflow: hidden;
  }
  .heart-wrap {
    position: absolute;
    bottom: -60px;
    animation-name: float-up;
    animation-timing-function: ease-out;
    animation-fill-mode: forwards;
  }
  .heart {
    display: inline-block;
    animation:
      sway 2.4s ease-in-out infinite alternate,
      glow 2s ease-in-out infinite alternate;
    opacity: 1;
  }
  @keyframes float-up {
    0% {
      transform: translateY(0) scale(0.7);
      opacity: 0;
    }
    10% {
      opacity: 1;
    }
    50% {
      transform: translateY(-50vh) scale(1);
    }
    80% {
      opacity: 1;
    }
    100% {
      transform: translateY(-105vh) scale(1.25);
      opacity: 0;
    }
  }
  @keyframes sway {
    0% {
      transform: translateX(-18px) rotate(-8deg);
    }
    50% {
      transform: translateX(0px) rotate(3deg);
    }
    100% {
      transform: translateX(18px) rotate(8deg);
    }
  }
  @keyframes glow {
    0% {
      text-shadow:
        0 0 2px rgba(255, 200, 210, 0.5),
        0 0 8px rgba(255, 120, 150, 0.4);
    }
    50% {
      text-shadow:
        0 0 4px rgba(255, 230, 240, 0.9),
        0 0 16px rgba(255, 150, 180, 0.8);
    }
    100% {
      text-shadow:
        0 0 2px rgba(255, 200, 210, 0.5),
        0 0 8px rgba(255, 120, 150, 0.4);
    }
  }
</style>
</head>
<body>
<canvas id="fw-canvas"></canvas>
<canvas id="stars-canvas"></canvas>
<div class="hearts" id="hearts-layer"></div>

<script>
const FW_COLORS = ["#ff6b6b", "#ffd93d", "#6bcbff", "#ff9ff3", "#1dd1a1", "#feca57", "#54a0ff"];
const FW_SCALE = 2;
const SNOW_COUNT = 120;
const SPARKLE_COUNT = 40;
const SNOW_EMOJIS = ["\u2744", "\u26c4", "\u{1F384}", "\u273b", "\u273c", "*"];
const HEART_COLORS = ["#ffffff", "#ffb3d9", "#ff6b9d", "#ff3b5c", "#ff9999"];
const HEART_CHARS = ["\u2764", "\u2661", "\u{1F496}", "\u{1F497}"];
const HEART_KEYWORDS = ["かわいい", "可愛い", "ハート", "heart", "すき", "好き", "like", "love"];
const STAR_SPAWN_INTERVAL = 120;
const STAR_GLOW_COLORS = ["#ff3bff", "#ff9bff", "#ff6b6b", "#ffcc00", "#ffee00", "#99ff66", "#66ddff", "#66aaff", "#cc99ff", "#ff6699", "#ff8844", "#ffb347", "#ffffff"];
const STAR_GLYPHS = ["\u2b50", "\u{1F31F}", "\u2726", "\u2727", "\u2729", "\u272a"];
const STAR_KEYWORDS = ["星", "ほし", "流れ星", "流星", "star", "stars", "shooting star", "shooting-star", "shooting stars", "shootingstars", "meteor", "meteor shower", "hoshi", "nagareboshi"];

let canvas, ctx;
let heartsContainer;
let heartTimer = null;
let heartActiveUntil = 0;
let starsCanvas, starsCtx;
let starWidth = 1920;
let starHeight = 1080;
let shootingStars = [];
let starParticles = [];
let starActiveUntil = 0;
let starLastSpawn = 0;
let starLastFrame = 0;
let starLoopRunning = false;
let rockets = [];
let particles = [];
let snowParticles = [];
let snowInitialized = false;
let snowActiveUntil = 0;

class Rocket {
  constructor() {
    const w = canvas.width;
    const h = canvas.height;
    this.x = w * (0.1 + Math.random() * 0.8);
    this.y = h + 10;
    this.vx = (Math.random() - 0.5) * 1.2;
    this.vy = -(6 + Math.random() * 2.5);
    this.targetY = h * (0.18 + Math.random() * 0.25);
    this.color = FW_COLORS[(Math.random() * FW_COLORS.length) | 0];
    this.history = [];
    this.alive = true;
  }
  update() {
    this.history.push({ x: this.x, y: this.y });
    if (this.history.length > 12) this.history.shift();
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.08;
    if (this.vy >= -0.5 || this.y <= this.targetY) {
      this.alive = false;
      multiBurst(this.x, this.y, this.color);
    }
  }
  draw() {
    ctx.lineWidth = 2 * FW_SCALE;
    for (let i = 0; i < this.history.length - 1; i++) {
      const p1 = this.history[i];
      const p2 = this.history[i + 1];
      const t = i / this.history.length;
      ctx.strokeStyle = `rgba(255,255,255,${0.2 + t * 0.6})`;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2.5 * FW_SCALE, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Particle {
  constructor(x, y, color, size, speed, angle, life, sparkle) {
    this.x = x;
    this.y = y;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.friction = 0.985;
    this.gravity = 0.06 + Math.random() * 0.04;
    this.size = size;
    this.life = life;
    this.maxLife = life;
    this.color = color;
    this.sparkle = sparkle;
  }
  update() {
    this.vx *= this.friction;
    this.vy *= this.friction;
    this.vy += this.gravity;
    this.x += this.vx;
    this.y += this.vy;
    this.life--;
  }
  draw() {
    const t = this.life / this.maxLife;
    if (t <= 0) return;
    let alpha = t;
    if (this.sparkle && (this.life % 5 < 2)) alpha *= 0.35;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * (0.6 + t), 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = alpha * 0.6;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 2.5 * t, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  get alive() {
    return this.life > 0;
  }
}

function createSnow(x, y) {
  return {
    type: "snow",
    x,
    y,
    r: 3 + Math.random() * 4,
    vy: 0.5 + Math.random() * 1.2,
    vx: -0.4 + Math.random() * 0.8,
    alpha: 0.5 + Math.random() * 0.5,
    twinkleSpeed: 0.002 + Math.random() * 0.003,
    twinkleOffset: Math.random() * Math.PI * 2,
  };
}

function createSparkle(x, y) {
  return {
    type: "sparkle",
    x,
    y,
    r: 2.5 + Math.random() * 2.5,
    vy: 0.3 + Math.random() * 0.8,
    vx: -0.3 + Math.random() * 0.6,
    alpha: 0.6 + Math.random() * 0.4,
    twinkleSpeed: 0.004 + Math.random() * 0.004,
    twinkleOffset: Math.random() * Math.PI * 2,
  };
}

function hexToHsl(hex) {
  hex = hex.replace("#", "");
  if (hex.length === 3) hex = hex.split("").map((c) => c + c).join("");
  const r = parseInt(hex.substr(0, 2), 16) / 255;
  const g = parseInt(hex.substr(2, 2), 16) / 255;
  const b = parseInt(hex.substr(4, 2), 16) / 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h *= 60;
  }
  return { h, s: s * 100, l: l * 100 };
}

function createSnow(x, y) {
  return {
    type: "snow",
    x,
    y,
    r: 2 + Math.random() * 3,
    vy: 0.5 + Math.random() * 1.2,
    vx: -0.4 + Math.random() * 0.8,
    alpha: 0.5 + Math.random() * 0.5,
    twinkleSpeed: 0.002 + Math.random() * 0.003,
    twinkleOffset: Math.random() * Math.PI * 2,
  };
}

function createSparkle(x, y) {
  return {
    type: "sparkle",
    x,
    y,
    r: 1.5 + Math.random() * 2,
    vy: 0.3 + Math.random() * 0.8,
    vx: -0.3 + Math.random() * 0.6,
    alpha: 0.6 + Math.random() * 0.4,
    twinkleSpeed: 0.004 + Math.random() * 0.004,
    twinkleOffset: Math.random() * Math.PI * 2,
  };
}

function starRand(min, max) {
  return Math.random() * (max - min) + min;
}

function starPick(arr) {
  return arr[(Math.random() * arr.length) | 0];
}

function spawnShootingStar() {
  const startX = starRand(starWidth * 0.1, starWidth + 400);
  const startY = starRand(-starHeight * 0.3, starHeight * 1);

  const angleDeg = 135 + starRand(-10, 10);
  const angle = (angleDeg * Math.PI) / 180;

  const speed = starRand(600, 1200);
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;

  const len = starRand(80, 200);
  const color = starPick(STAR_GLOW_COLORS);
  const life = starRand(1.2, 2.2);
  const size = starRand(48, 144);
  const spinSpeed = starRand(-2, 2);

  shootingStars.push({
    x: startX,
    y: startY,
    vx,
    vy,
    length: len,
    color,
    life,
    age: 0,
    glyph: starPick(STAR_GLYPHS),
    size,
    spin: 0,
    spinSpeed,
  });
}

function spawnStarParticles(x, y, baseColor) {
  const count = Math.floor(starRand(6, 14));
  for (let i = 0; i < count; i++) {
    const angle = starRand(0, Math.PI * 2);
    const speed = starRand(20, 160);
    starParticles.push({
      x,
      y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: starRand(1, 4),
      life: starRand(0.3, 0.9),
      age: 0,
      color: baseColor,
    });
  }
}

function drawShootingStar(s) {
  const angle = Math.atan2(s.vy, s.vx);
  const tailX = s.x - Math.cos(angle) * s.length;
  const tailY = s.y - Math.sin(angle) * s.length;

  const grad = starsCtx.createLinearGradient(s.x, s.y, tailX, tailY);
  grad.addColorStop(0, "rgba(255,255,255,1)");
  grad.addColorStop(0.2, s.color);
  grad.addColorStop(1, "rgba(255,255,255,0)");

  starsCtx.lineWidth = 2.8;
  starsCtx.strokeStyle = grad;
  starsCtx.beginPath();
  starsCtx.moveTo(s.x, s.y);
  starsCtx.lineTo(tailX, tailY);
  starsCtx.stroke();

  starsCtx.save();
  starsCtx.translate(s.x, s.y);
  starsCtx.rotate(s.spin);
  starsCtx.font = `${s.size}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", system-ui, sans-serif`;
  starsCtx.textAlign = "center";
  starsCtx.textBaseline = "middle";
  starsCtx.shadowColor = s.color;
  starsCtx.shadowBlur = 30;
  starsCtx.fillStyle = "#fff";
  starsCtx.fillText(s.glyph, 0, 0);
  starsCtx.restore();
}

function drawStarParticle(p) {
  const alpha = 1 - p.age / p.life;
  if (alpha <= 0) return;
  starsCtx.globalAlpha = alpha;
  starsCtx.fillStyle = p.color;
  starsCtx.beginPath();
  starsCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
  starsCtx.fill();
  starsCtx.globalAlpha = 1;
}

function starLoop(now) {
  const dt = (now - starLastFrame) / 1000;
  starLastFrame = now;

  starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
  starsCtx.globalCompositeOperation = "lighter";

  if (now < starActiveUntil && now - starLastSpawn > STAR_SPAWN_INTERVAL) {
    spawnShootingStar();
    if (Math.random() < 0.35) spawnShootingStar();
    starLastSpawn = now;
  }

  for (let i = shootingStars.length - 1; i >= 0; i--) {
    const s = shootingStars[i];
    s.age += dt;
    if (s.age > s.life) {
      shootingStars.splice(i, 1);
      continue;
    }
    s.x += s.vx * dt;
    s.y += s.vy * dt;
    s.spin += s.spinSpeed * dt;

    if (Math.random() < 0.6) {
      spawnStarParticles(s.x, s.y, s.color);
    }

    drawShootingStar(s);
  }

  for (let i = starParticles.length - 1; i >= 0; i--) {
    const p = starParticles[i];
    p.age += dt;
    if (p.age > p.life) {
      starParticles.splice(i, 1);
      continue;
    }
    p.vx *= 0.98;
    p.vy = p.vy * 0.98 + 5 * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    drawStarParticle(p);
  }

  starsCtx.globalCompositeOperation = "source-over";

  if (now < starActiveUntil || shootingStars.length || starParticles.length) {
    requestAnimationFrame(starLoop);
  } else {
    starLoopRunning = false;
    starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
  }
}

function triggerShootingStars() {
  if (!starsCtx) return;
  const now = performance.now();
  starActiveUntil = Math.max(starActiveUntil, now + 9000);
  if (!starLoopRunning) {
    starLoopRunning = true;
    starLastFrame = now;
    starLastSpawn = now;
    requestAnimationFrame(starLoop);
  }
}

function createHeart() {
  if (!heartsContainer) return;
  const wrap = document.createElement("div");
  wrap.classList.add("heart-wrap");

  const heart = document.createElement("span");
  heart.classList.add("heart");
  heart.style.color = HEART_COLORS[(Math.random() * HEART_COLORS.length) | 0];
  heart.style.fontSize = 40 + Math.random() * 60 + "px";
  heart.textContent = HEART_CHARS[(Math.random() * HEART_CHARS.length) | 0];

  wrap.style.left = Math.random() * 100 + "vw";
  const duration = 6 + Math.random() * 4;
  wrap.style.animationDuration = duration + "s";
  wrap.style.animationDelay = -Math.random() * duration + "s";

  wrap.appendChild(heart);
  heartsContainer.appendChild(wrap);

  setTimeout(() => wrap.remove(), (duration + 2) * 1000);
}

function triggerHeartsBurst() {
  const now = performance.now();
  heartActiveUntil = Math.max(heartActiveUntil, now + 6500);
  if (!heartTimer) {
    heartTimer = setInterval(() => {
      if (performance.now() > heartActiveUntil) {
        clearInterval(heartTimer);
        heartTimer = null;
        return;
      }
      createHeart();
    }, 160);
  }
  for (let i = 0; i < 15; i++) {
    setTimeout(createHeart, i * 120);
  }
}

function burst(x, y, baseColor, count, baseSpeed, scale) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = baseSpeed * (0.5 + Math.random()) * FW_SCALE;
    const size = (1.8 * scale + Math.random() * 1.5 * scale) * FW_SCALE;
    const c = hexToHsl(baseColor);
    const h = (c.h + (Math.random() * 40 - 20) + 360) % 360;
    const s = Math.min(100, c.s + (Math.random() * 20 - 10));
    const l = Math.min(70, c.l + (Math.random() * 10 - 5));
    const color = `hsl(${h},${s}%,${l}%)`;
    const life = 50 + Math.random() * 40;
    const sparkle = Math.random() < 0.7;
    particles.push(new Particle(x, y, color, size, speed, angle, life, sparkle));
  }
}

function multiBurst(x, y, baseColor) {
  burst(x, y, baseColor, 70, 3.5, 1.0);
  setTimeout(() => burst(x, y, baseColor, 50, 2.8, 0.7), 140);
  setTimeout(() => burst(x, y, baseColor, 40, 2.2, 0.5), 280);
}

function resize() {
  const w = window.innerWidth || 1920;
  const h = window.innerHeight || 1080;
  canvas.width = w;
  canvas.height = h;
  if (starsCanvas && starsCtx) {
    const dpr = window.devicePixelRatio || 1;
    starWidth = w;
    starHeight = h;
    starsCanvas.width = w * dpr;
    starsCanvas.height = h * dpr;
    starsCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
}

function ensureSnowInit() {
  if (snowInitialized) return;
  for (let i = 0; i < SNOW_COUNT; i++) {
    snowParticles.push(createSnow(Math.random() * canvas.width, Math.random() * canvas.height));
  }
  for (let i = 0; i < SPARKLE_COUNT; i++) {
    snowParticles.push(createSparkle(Math.random() * canvas.width, Math.random() * canvas.height));
  }
  snowInitialized = true;
}

function update() {
  // 毎フレーム完全クリアして透過を維持
  ctx.globalCompositeOperation = "source-over";
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // スノー（通常合成）
  const now = performance.now();
  if (snowActiveUntil > now) {
    ensureSnowInit();
    snowParticles.forEach((p) => {
      // update
      p.y += p.vy;
      p.x += p.vx;
      const tw = 0.5 + 0.5 * Math.sin(now * p.twinkleSpeed + p.twinkleOffset);
      p.x += Math.sin(now * p.twinkleSpeed + p.twinkleOffset) * (p.type === "snow" ? 0.6 : 0.4);
      if (p.y > canvas.height + 20) {
        p.y = -10;
        p.x = Math.random() * canvas.width;
      }
      if (p.x < -20) p.x = canvas.width + 10;
      if (p.x > canvas.width + 20) p.x = -10;

      // draw
      ctx.save();
      ctx.globalAlpha = p.alpha * tw;
      ctx.fillStyle = "#ffffff";
      if (p.type === "snow") {
        // 絵文字スノーを混ぜる
        if (Math.random() < 0.4) {
          const emoji = SNOW_EMOJIS[(Math.random() * SNOW_EMOJIS.length) | 0];
          ctx.font = `${p.r * 4}px "Segoe UI Emoji", "Noto Color Emoji", system-ui, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowBlur = 8;
          ctx.shadowColor = "rgba(255,255,255,0.9)";
          ctx.fillText(emoji, p.x, p.y);
        } else {
          ctx.shadowBlur = 8;
          ctx.shadowColor = "rgba(255,255,255,0.8)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        ctx.shadowBlur = 12;
        ctx.shadowColor = "rgba(255,255,255,1)";
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - p.r);
        ctx.lineTo(p.x + p.r, p.y);
        ctx.lineTo(p.x, p.y + p.r);
        ctx.lineTo(p.x - p.r, p.y);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    });
  }

  // 発光合成で花火描画
  ctx.globalCompositeOperation = "lighter";
  rockets.forEach((r) => r.update());
  rockets = rockets.filter((r) => r.alive);
  rockets.forEach((r) => r.draw());

  particles.forEach((p) => p.update());
  particles = particles.filter((p) => p.alive);
  particles.forEach((p) => p.draw());

  requestAnimationFrame(update);
}

function triggerFireworkCanvas(count = 3) {
  for (let i = 0; i < count; i++) {
    rockets.push(new Rocket());
    if (Math.random() < 0.35) rockets.push(new Rocket());
  }
}

function init() {
  canvas = document.getElementById("fw-canvas");
  ctx = canvas.getContext("2d");
  starsCanvas = document.getElementById("stars-canvas");
  starsCtx = starsCanvas.getContext("2d");
  heartsContainer = document.getElementById("hearts-layer");
  resize();
  window.addEventListener("resize", resize);
  ctx.globalCompositeOperation = "lighter";
  update();
}

// コメントからキーワードを検知して花火を打ち上げる
const seen = new Set();
let initialized = false; // 初回は履歴だけ既読にして花火を出さない
const fireKeywords = ["花火", "はなび", "hanabi", "firework", "fireworks"];
const snowKeywords = ["雪", "ゆき", "snow"];

function extractText(msg) {
  if (!msg) return "";
  if (Array.isArray(msg.parts) && msg.parts.length > 0) {
    return msg.parts.filter((p) => p.type === "text").map((p) => p.text || "").join(" ");
  }
  return msg.text || "";
}

function containsFirework(msg) {
  const t = extractText(msg).toLowerCase();
  if (!t) return false;
  return fireKeywords.some((k) => t.includes(k));
}

function containsSnow(msg) {
  const t = extractText(msg).toLowerCase();
  if (!t) return false;
  return snowKeywords.some((k) => t.includes(k));
}

function containsHeart(msg) {
  const t = extractText(msg).toLowerCase();
  if (!t) return false;
  return HEART_KEYWORDS.some((k) => t.includes(k));
}

function containsStar(msg) {
  const t = extractText(msg).toLowerCase();
  if (!t) return false;
  return STAR_KEYWORDS.some((k) => t.includes(k));
}

async function pollManualTriggers() {
  try {
    const res = await fetch("/trigger-effect/pull");
    const events = await res.json();
    for (const ev of events) {
      switch (ev.type) {
        case "firework":
          triggerFireworkCanvas(4);
          break;
        case "snow":
          snowActiveUntil = performance.now() + 9000;
          break;
        case "heart":
          triggerHeartsBurst();
          break;
        case "star":
          triggerShootingStars();
          break;
      }
    }
  } catch (e) {
    console.warn("manual effects poll error", e);
  }
}
async function pollComments() {
  try {
    const res = await fetch("/comments");
    const data = await res.json();
    let sawAny = false;
    for (const msg of data) {
      const id = msg.id || (msg.timestamp_ms + "_" + (msg.author || "") + "_" + (msg.text || ""));
      if (seen.has(id)) continue;
      sawAny = true;
      seen.add(id);

      // 初回の履歴は既読扱いでスキップ
      if (!initialized) continue;

      if (containsFirework(msg)) {
        // 花火だけ上げる
        triggerFireworkCanvas(4);
      }
      if (containsSnow(msg)) {
        snowActiveUntil = performance.now() + 9000; // 9秒ほど降らせる
      }
      if (containsStar(msg)) {
        triggerShootingStars();
      }
      if (containsHeart(msg)) {
        triggerHeartsBurst();
      }
    }
    if (!initialized && sawAny) {
      initialized = true;
    }
  } catch (e) {
    console.warn("effects poll error", e);
  }
}

init();
setInterval(pollComments, 500);
setInterval(pollManualTriggers, 500);
</script>
</body>
</html>
